2021/12/13
#### 1、Falsy（虚值）和Truthy（真值）
* ***falsy 值 (虚值)*** 是在 Boolean 上下文中认定为 false 的值。
* JavaScript 在需要用到布尔类型值的上下文中使用==强制类型转换==(Type Conversion )将值转换为布尔值，例如条件语句和循环语句。
* 在 JavaScript 中只有 ==8 个==falsy 值。

| 值 | 描述 |
| --- | --- |
| false | false关键字 |
| 0 | 数值0 |
| -0 | 数值-0 |
| 0n | 当 BigInt 作为布尔值使用时, 遵从其作为数值的规则. 0n 是 falsy 值 console.log(Boolean(1n)) // true, console.log(Boolean(0n)) // false |
| "",'',`` | 这是一个空字符串 (字符串的长度为零). JavaScript 中的字符串可用双引号 "", 单引号 '', 或 模板字面量 `` 定义。|
| null | null-缺少值 |
| undefined |undefined-原始值 |
| NaN | NaN-非数值 |

* 在 JavaScript 中，***truthy（真值）*** 指的是在布尔值上下文中，转换后的值为真的值。所有值都是真值，除非它们被定义为假值（即除 false、0、-0、0n、""、null、undefined 和 NaN 以外皆为真值）。

#### 2、ES5变量提升
***执行环境***
  * 全局执行环境：在web浏览器中，我们可以认为==表示全局执行环境的对象==[^表示执行环境的对象]是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的，代码载入浏览器时，全局环境被创建，应用程序退出，如关闭网页或者浏览器时，全局执行环境被销毁。
[^表示执行环境的对象]: 全局执行环境是最外围的一个执行环境，根据ECMAscript实现所在的宿主环境不同，表示执行环境的对象也不同
  * 函数执行环境：每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，==把控制权返回给之前的执行环境==。

***作用域***
  * 全局作用域：全局对象的作用域，任意地方都可以访问到（如果没有被函数作用域覆盖）
  * 函数作用域：整个函数范围

***变量/函数提升***
1、所有声明都会被提升到变量/函数所在作用域的最顶上
```javascript
  //案例1：
  console.log(a); // undefined
  var a = 10;
  console.log(a);// 10
  function test() {
    console.log(a); // undefined
    var a = 20;
    console.log(a);// 20
  }

  //上述等价于

  var a; // 变量声明提升
  console.log(a);// undefined
  a = 10;
  console.log(a);// 10
  function test() {
    var a; // 变量声明提升
    console.log(a);// undefined
    a = 20;
    console.log(a);// 20
  }
```
```javascript
  // 案例2：复杂一点
  console.log("1",a);// undefined
  var a = 10;
  console.log("2",a);// 10
  test();
  function test() { 
    console.log("3",a);// undefined
    var a = 20;
    console.log("4",a);// 20 
    console.log("window.a =",window.a); // 10 
    window.a = a; // 20 
  }
  console.log("5",a);// 20 
  console.log("window.a =", window.a); // 20

  //上述等价于

  var a; // 全局变量a ，会提升到全局执行环境最顶部，为window的属性，等价于window.a
  console.log("1",a);// undefined
  a = 10;
  console.log("2",a);// 10
  function test() { // 全局函数 ，为window的属性，等价于window.test();
    var a; // 局部变量a，会提升到局部执行环境最顶部
    console.log("3",a);// undefined
    a = 20;
    console.log("4",a);// 20 访问的局部变量a
    console.log("window.a =",window.a); // 10 访问的全局变量a等价于window.a
    window.a = a; // 20 // 将局部变量a的值赋值给全局变量a
  }
  test(); // 函数声明提升（是先调用后声明也可执行成功的原因）
  console.log("5",a);// 20 访问的全局变量a等价于window.a
  console.log("window.a =", window.a); // 20
```
```javascript
  // 案例3：
  function add(){
    console.log(y); // undefined 访问的是局部变量
    var y = 10;
    console.log(y); // 10
  }
  add();
  console.log(y); // undefined

  //上述等价于

  function add(){
    var y;
    console.log(y); // undefined
    y = 10;
    console.log(y); // 10
  }
  add();
  console.log(y); // undefined
```
```javascript
  // 案例4：
  var b = 10;
  function add(){
    console.log(b); // 10 访问的是全局变量
    b = 20; // 更改全局变量
    console.log(b); // 20
  }
  add();
  console.log(b); // 20
```
2、同一个变量/函数声明只进行一次，并且因此其他声明都会被忽略；
```javascript
  var a = 10;
  console.log(a); // a = 10
  var a = 20;
  console.log(a); // a = 20
  console.log("window.a =", window.a); // 20
```
3、函数声明的优先级优于变量声明，且函数声明会连带定义一起被提升
```javascript
  console.log(test3); // ƒ test3(){console.log('func');}
  function test3(){console.log('func');}
  var test3 = 'Mary';
```
***more***
函数提升会将函数声明连带定义一起提升。

在JavaScript中函数的创建方式有三种：函数声明、函数表达式（函数字面量）、函数构造法（动态的，匿名的）。只有函数声明创建的函数会==执行函数提升==，字面量定义的函数（实质为变量+匿名函数）会==执行变量提升==。
```javascript
test1();
function test1(){
    console.log("可以被提升");
}

test2(); // Uncaught TypeError: test2 is not a function
var test2 = function(){
    console.log("不可以被提升");
}

console.log(test2); // undefined
var test2 = function(){
   console.log("不可以被提升");
} 
// 等价于
var test2;
console.log(test2); // undefined
test2 = function(){
   console.log("不可以被提升");
} 
```

#### 3、闭包与匿名函数


